{"version":3,"sources":["modules/dataController/actions.js","modules/dataController/reducer.js","modules/dataController/store.js","modules/dataController/AppDataController.js","components/Action Commands/ActionButton.js","components/Header.js","components/Action Commands/ActionMenuItem.js","modules/dataController/TaskDataController.js","components/Action Commands/ActionMenu.js","components/Undo/UndoButton.js","components/Tasks/Task.js","components/Tasks/TaskList.js","components/newSection/SectionButton.js","components/newSection/sectionAddTask.js","components/newSection/SectionBar.js","components/newSection/SectionContainer.js","components/newSection/SectionList.js","components/otherDisplays/sideBarButton.js","components/otherDisplays/sideBarElement.js","components/otherDisplays/sideBarList.js","components/otherDisplays/sideListElementTask.js","components/otherDisplays/sideListElement.js","components/otherDisplays/sideList.js","components/SideBarBackground.js","App.js","index.js"],"names":["CREATE_TASK","DELETE_TASK","UPDATE_TASK_TEXT","TOGGLE_TASK_COMPLETION","DELETE_ALL_COMPLETED_TASK","TOGGLE_TODO_LIST","TOGGLE_COMPLETED_LIST","SHOW_MENU","HIDE_MENU","UNDO_TASK","SHOW_UNDO","HIDE_UNDO","CREATE_SECTION","DELETE_SECTION","UPDATE_SECTION_TEXT","TOGGLE_SECTION","CLEAR_ALL","initialState","stack","sections","text","isToggled","identifier","tasks","showUndo","showMenu","createTask","state","sectionIdentifier","task","isCompleted","id","uuidv4","sectionID","newSections","map","x","find","section","push","deleteTask","filter","updateTaskText","returnedSections","taskToChange","toggleTaskCompletion","sectionWithTask","taskIndex","indexOf","splice","completedSection","completedTask","deleteAllCompletedTasks","undoTask","pop","toggleCompletedList","showCompleted","toggleToDoList","showTodo","hideMenu","hideUndo","createSection","console","log","completedSectionIndex","deleteSection","updateSectionText","toggleSection","sectionToToggle","clearAll","store","createStore","action","type","payload","AppDataController","dispatch","getState","handleOnClick","ActionButton","class","onClick","icon","faPlus","Header","props","ActionMenuItem","command","TaskDataController","updateTaskTextAction","toggleTaskCompletionAction","createTaskAction","deleteTaskAction","deleteSectionAction","updateSectionTextAction","toggleSectionAction","menuItems","deleteAllCompleted","faMinus","clearAllSectionsAndTasks","setTimeout","ActionMenu","closeMenu","menuItem","key","UndoButton","alt","Task","cssID","currentSectionText","getAriaCheckbox","value","onChange","e","checked","getAriaTask","event","currentTarget","handleTextEvent","TaskList","SectionButton","toggledState","faAngleDown","faAngleRight","sectionText","ariaText","SectionAddTaskButton","SectionBar","classes","checkIfTypeIsCompleted","sectionTitle","SectionContainer","className","connect","ownProps","getSections","SideBarButton","document","getElementById","scrollIntoView","behavior","block","inline","SideBarElement","SideListElementTask","SideListElement","SideBarBackground","menuIsActive","undoIsActive","ReactDOM","render"],"mappings":"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","file":"static/js/main.dd85f270.chunk.js","sourcesContent":["export const CREATE_TASK = \"createTask\"\nexport const DELETE_TASK = \"deleteTask\"\nexport const UPDATE_TASK_TEXT = \"updateTaskText\"\nexport const TOGGLE_TASK_COMPLETION = \"toggleTaskCompletion\"\nexport const DELETE_ALL_COMPLETED_TASK = \"deleteAllCompletedTasks\"\nexport const TOGGLE_TODO_LIST = \"toggleTodoList\"\nexport const TOGGLE_COMPLETED_LIST = \"toggleCompletedList\"\nexport const SHOW_MENU = \"showMenu\"\nexport const HIDE_MENU = \"hideMenu\"\nexport const UNDO_TASK = \"undoTask\"\nexport const SHOW_UNDO = \"showUndo\"\nexport const HIDE_UNDO = \"hideUndo\"\n\n\nexport const CREATE_SECTION = \"createSection\"\nexport const DELETE_SECTION = \"deleteSection\"\nexport const UPDATE_SECTION_TEXT = \"updateSectionText\"\nexport const TOGGLE_SECTION = \"toggleSection\"\n\nexport const CLEAR_ALL = \"clearAllSectionsAndTasks\"\n\nexport const showUndoAction = () => ({type:SHOW_UNDO})\nexport const hideUndoAction = () => ({type:HIDE_UNDO})\nexport const undoTaskAction = () => ({type:UNDO_TASK})\nexport const showMenuAction = () => ({type:SHOW_MENU})\nexport const hideMenuAction = () => ({type:HIDE_MENU})\nexport const createTaskAction = (sectionIdentifier) => ({type:CREATE_TASK, payload:{sectionIdentifier}})\nexport const deleteTaskAction = (id) => ({type:DELETE_TASK, payload:{id}})\nexport const updateTaskTextAction = (id, identifier, text) => ({type: UPDATE_TASK_TEXT,payload: {id, identifier, text}})\nexport const toggleTaskCompletionAction = (id, identifier) => ({type: TOGGLE_TASK_COMPLETION,payload:{id, identifier}})\nexport const deleteAllCompletedTasksAction = () => ({type: DELETE_ALL_COMPLETED_TASK})\nexport const toggleCompletedListAction = () => ({type:TOGGLE_COMPLETED_LIST})\nexport const toggleToDoListAction = () => ({type:TOGGLE_TODO_LIST})\n\n// functions for creating/deleting/editing section properties\n\nexport const createSectionAction = () => ({type: CREATE_SECTION})\nexport const deleteSectionAction = (sectionIdentifier) => ({type: DELETE_SECTION, payload: {sectionIdentifier}})\nexport const updateSectionTextAction = (sectionIdentifier,text) => ({type: UPDATE_SECTION_TEXT,payload: {sectionIdentifier, text}})\n\n// function for toggling a section by just taking in id\n\nexport const toggleSectionAction = (sectionIdentifier) => ({type: TOGGLE_SECTION, payload: {sectionIdentifier}})\n\n// function for clearing all sections and resetting all\n\nexport const clearAllSectionsAndTasksAction = () => ({type: CLEAR_ALL})\n","/* eslint-disable no-lone-blocks */\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n    CREATE_TASK,\n    DELETE_ALL_COMPLETED_TASK,\n    DELETE_TASK,\n    HIDE_MENU,\n    HIDE_UNDO,\n    SHOW_MENU,\n    SHOW_UNDO,\n    TOGGLE_COMPLETED_LIST,\n    TOGGLE_TASK_COMPLETION,\n    TOGGLE_TODO_LIST,\n    TOGGLE_UNDO,\n    UNDO_TASK,\n    UPDATE_TASK_TEXT,\n    CREATE_SECTION,\n    DELETE_SECTION,\n    UPDATE_SECTION_TEXT,\n    TOGGLE_SECTION,\n    CLEAR_ALL\n} from './actions';\n\nconst initialState = {\n    stack:[],\n    sections: [{text:\"To Do\", isToggled:false, identifier:\"toDo\", tasks: []}, {text:\"Completed\", isToggled:false, identifier:\"completed\", tasks:[]}],\n    showUndo: false,\n    showMenu: false \n}\n\n\n// Gets the sectionID from the section it's called on, creates a new task containing that sectionID, then appends it\n// to the section's tasks list in initialState.\n\nfunction createTask(state, sectionIdentifier) {\n    const id = uuidv4()\n    const sectionID = sectionIdentifier\n    const task = {text:\"\",isCompleted:false,id, sectionID}\n    const newSections = state.sections.map(x => x)\n    const sectionToChange = newSections.find(section => section.identifier === sectionIdentifier)\n\n    const newSection = sectionToChange.tasks.push(task)\n\n    return {\n        ...state,\n        sections:newSections\n    }\n}\n\n// Deletes a task with the given id.\n\nfunction deleteTask(state,id) {\n    const tasks = state.tasks.filter(task => task.id !== id)\n    return {\n        ...state,\n        tasks\n    }\n}\n\n\n\n\n\n\n// Updates a task's text given it's id, section identifier, and text to update it to.\n// identifier is needed to find which section the task will be located in.\n\nfunction updateTaskText(state,{id, identifier,text}) {\n    const returnedSections = state.sections.map(x => x)\n    const sectionWithTask = returnedSections.find(section => section.identifier === identifier)\n    const newTasks = sectionWithTask.tasks.map(x => x)\n    const taskToChange = newTasks.find(task => task.id === id)\n    if (!taskToChange) return state\n\n    taskToChange.text = text\n\n\n    return {\n        ...state,\n        sections: returnedSections\n    }\n}\n\n// oh boy this is a doozy.\n// The reason why this function is so big is that it needs to account for when the task that's being checked is not\n// present in the same section as it's section Identifier. While it might have a sectionIdentifier, it might be in\n// the completed section, which means we can not locate the task with it's section identifier.\n\nfunction toggleTaskCompletion(state,{id, identifier}) {\n    const returnedSections = state.sections.map(x => x)\n    const sectionWithTask = returnedSections.find(section => section.identifier === identifier)\n    const taskToChange = sectionWithTask.tasks.find(task => task.id === id)\n    // create a copy of sections, find the section with the task and then get the task from the section.\n\n    if (!taskToChange){\n        // if it's null, the task is not present there, meaning it must be in completed, meaning it's being moved\n        // from completed to another section and removed from completed, which happens here.\n        const completedSection = returnedSections.find(section => section.identifier === \"completed\")\n        const completedTask = completedSection.tasks.find(task => task.id === id)\n        let taskIndex = completedSection.tasks.indexOf(completedTask)\n        completedTask.isCompleted = !completedTask.isCompleted\n        returnedSections.find(section => section.identifier === identifier).tasks.push(completedTask)\n        returnedSections.find(section => section.identifier === \"completed\").tasks.splice(taskIndex, 1)\n    }\n    else{\n        // here it's located the task, and is now moving it to the completed section and removing it from it's origin\n        // section.\n        let taskIndex = sectionWithTask.tasks.indexOf(taskToChange)\n        taskToChange.isCompleted = !taskToChange.isCompleted\n        returnedSections.find(section => section.identifier === \"completed\").tasks.push(taskToChange)\n        returnedSections.find(section => section.identifier === identifier).tasks.splice(taskIndex, 1)\n    }\n\n    return {\n        ...state,\n        sections:returnedSections\n    }\n\n}\n\n// deletes all tasks from the completed tasks section.\n// stack.push is also here to implement an undo functionality, but this was very broken and eventually settled\n// on not having it work.\n\nfunction deleteAllCompletedTasks(state) {\n    const stack = state.stack.map(x => x)\n    stack.push(state.sections)\n    const newSections = state.sections.map(x => x)\n    newSections.find(section => section.identifier === \"completed\").tasks = []\n\n   return {\n       ...state,\n       stack,\n       sections:newSections\n   }\n}\n\n// in the event of an undo button, the sections stored on the stack will be popped and returned to sections.\n\nfunction undoTask(state) {\n    const stack = state.stack.map(x => x)\n    const newSections = stack.pop()\n    return {\n        ...state,\n        sections: newSections,\n        stack \n    }\n}\n\n\nfunction toggleCompletedList(state) {\n    return {\n        ...state,\n        showCompleted: !state.showCompleted\n    }\n}\n\nfunction toggleToDoList(state) {\n    return {\n        ...state,\n        showTodo: !state.showTodo \n    }\n}\n\nfunction showMenu(state) {\n    return {\n        ...state,\n        showMenu: true \n        }\n}\n\nfunction hideMenu(state) {\n    return {\n        ...state,\n        showMenu:false \n    }\n}\n\nfunction showUndo(state) {\n    return {\n        ...state,\n        showUndo: true\n    }\n}\n\nfunction hideUndo(state) {\n    return {\n        ...state,\n        showUndo: false \n    }\n}\n\n\n// function for creating a section, this will push a new empty section onto the state's sections.\n\nfunction createSection(state) {\n    const identifier = uuidv4()\n    const section = {text:\"\",isToggled:false, identifier: identifier, tasks: []}\n    const newSections = state.sections.map(x => x)\n    console.log(\"Hello!\")\n    const completedSection = newSections.find(section => section.identifier === \"completed\")\n    let completedSectionIndex = newSections.indexOf(completedSection)\n    newSections.splice(completedSectionIndex, 1)\n    newSections.push(completedSection)\n    return {\n        ...state,\n        sections:newSections\n    }\n}\n\n// finds a section via it's sectionIdentifier and uses filter to remove it.\n\nfunction deleteSection(state, sectionIdentifier) {\n    const sections = state.sections.filter(sections => sections.identifier !== sectionIdentifier)\n    return {\n        ...state,\n        sections\n    }\n}\n\n\n// Similar to updating a task's text, updates a section's text with help from it's sectionIdentifier.\n\nfunction updateSectionText(state,{sectionIdentifier,text}){\n    const newSections = state.sections.map(x => x)\n    const section = newSections.find(section => section.identifier === sectionIdentifier)\n    if (!section) return state\n    section.text = text\n\n    return {\n        ...state,\n        sections: newSections\n    }\n}\n\n// This will toggle whether the section's button is pressed or not, and will show the tasklist or hide it\n// depending on whether it's toggled or not.\n\nfunction toggleSection(state, sectionIdentifier) {\n    const newSections = state.sections.map(x => x)\n    const sectionToToggle = newSections.find(section => section.identifier === sectionIdentifier)\n    if (!sectionToToggle) return state\n\n    sectionToToggle.isToggled = !sectionToToggle.isToggled\n    return {\n        ...state,\n        sections: newSections\n    }\n}\n\n// Clears all tasks and sections, and resets them to the default value when loading the page. It also pushes\n// the sections onto the stack because undo functionality works with this but doesn't work with the other one,\n// and I have no idea why.\n\nfunction clearAll(state){\n    console.log(\"clear all sections\")\n    console.log(state.sections)\n    const stack = state.stack.map(x => x)\n    stack.push(state.sections)\n    const newSections = [{text:\"To Do\", isToggled:false, identifier:\"toDo\", tasks: []}, {text:\"Completed\", isToggled:false, identifier:\"completed\", tasks:[]}]\n    return{\n        ...state,\n        stack,\n        sections:newSections\n    }\n}\n\n\nexport default function toDoReducer(state = initialState, action){\n    switch (action.type){\n        case CREATE_TASK: return createTask(state, action.payload.sectionIdentifier)\n        case DELETE_TASK: return deleteTask(state,action.payload.id)\n        case UPDATE_TASK_TEXT: return updateTaskText(state,action.payload)\n        case TOGGLE_TASK_COMPLETION: return toggleTaskCompletion(state,action.payload)\n        case DELETE_ALL_COMPLETED_TASK: return deleteAllCompletedTasks(state)\n        case TOGGLE_TODO_LIST: return toggleToDoList(state)\n        case TOGGLE_COMPLETED_LIST: return toggleCompletedList(state)\n        case SHOW_MENU: return showMenu(state)\n        case HIDE_MENU: return hideMenu(state)\n        case UNDO_TASK: return undoTask(state)\n        case SHOW_UNDO: return showUndo(state)\n        case HIDE_UNDO: return hideUndo(state)\n        case CREATE_SECTION: return createSection(state)\n        case DELETE_SECTION: return deleteSection(state,action.payload.sectionIdentifier)\n        case UPDATE_SECTION_TEXT: return updateSectionText(state, action.payload)\n        case TOGGLE_SECTION: return toggleSection(state, action.payload.sectionIdentifier)\n        case CLEAR_ALL: return clearAll(state)\n        default:\n            return state \n    }\n\n\n}","import {createStore} from \"redux\"\nimport rootReducer  from \"./reducer\"\n\nconst store = createStore(rootReducer)\nexport default store ","import { hideMenuAction, hideUndoAction, showMenuAction, showUndoAction, toggleCompletedListAction, toggleToDoListAction, toggleUndoAction, undoTaskAction } from \"./actions.js\"\nimport store from \"./store.js\"\n\nexport default class AppDataController {\n\n    static toggleTodoList() {\n        const action = toggleToDoListAction()\n        store.dispatch(action)\n    }\n\n    static showToDo() {\n        return store.getState().showTodo \n    }\n    \n    static showCompleted() {\n        return store.getState().showCompleted \n    }\n\n    static showMenu() {\n        const action = showMenuAction()\n        store.dispatch(action)\n    }\n\n    static closeMenu() {\n        const action = hideMenuAction()\n        store.dispatch(action)\n    }\n\n    static menuIsActive() {\n        return store.getState().showMenu \n    }\n\n    static toggleCompletedList() {\n        const action = toggleCompletedListAction()\n        store.dispatch(action)\n    }\n\n    static showUndo() {\n        const action = showUndoAction()\n        store.dispatch(action)\n    }\n\n    static hideUndo() {\n        const action = hideUndoAction()\n        store.dispatch(action)\n    }\n\n    static undoTask() {\n        const action = undoTaskAction()\n        store.dispatch(action)\n    }\n\n    static undoIsActive() {\n        return store.getState().showUndo \n    }\n\n}","import AppDataController from \"../../modules/dataController/AppDataController\"\nimport \"../../css/action_button.css\"\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\"\nimport { faPlus } from \"@fortawesome/free-solid-svg-icons\"\n\nfunction handleOnClick() {\n    AppDataController.showMenu()\n}\n\n// Action button in the bottom right corner, allows access to adding sections, clearing completed tasks, or\n    // resetting the sections and tasks.\n\nexport default function ActionButton() {\n    return (\n        <button\n            aria-label=\"Click here to hear more options.\"\n            class=\"action-button\"\n            onClick={handleOnClick}\n        >\n        <FontAwesomeIcon icon={faPlus} />\n        </button>\n    )\n}\n\n","import \"../css/banner.css\"\n\n\n\n// Just a silly banner for the top of the page that shows a play on \"toDos\"\nexport default function Header(props) {\n\n    return (\n        <div class=\"banner\">\n            <h1 class=\"title\"> Todoiz.IO</h1>\n        </div>\n    )\n}","\n\n\n/* \n\n\nprops: {\n    text: string;\n    command: Function\n    parameters: string\n    icon: FontAwesomeIcon\n}\n*/\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nexport default function ActionMenuItem(props) {\n    // creates a button in the action menu with a command from props.\n    return (\n        <button onClick={() => props.command(props)} class=\"action-item\"\n            aria-label={\"This is the\" + props.text + \"button in the action menu, Press to perform the action.\" }>\n            { props.icon && <FontAwesomeIcon icon= {props.icon}/> }\n            <div class=\"action-text\">\n                <p> {props.text} </p>\n            </div>\n        </button>\n    )\n}\n\n","import { createTaskAction, deleteAllCompletedTasksAction, deleteTaskAction, toggleTaskCompletionAction, updateTaskTextAction, createSectionAction, deleteSectionAction, updateSectionTextAction, toggleSectionAction, clearAllSectionsAndTasksAction } from \"./actions\"\nimport store from \"./store.js\"\nclass TaskDataController {\n    static updateTaskText(id, identifier, text) {\n            const action = updateTaskTextAction(id, identifier ,text)\n            store.dispatch(action)\n    }\n\n    static toggleTaskCompletion(id, identifier) {\n        const action = toggleTaskCompletionAction(id, identifier)\n        store.dispatch(action)\n    }\n\n    static createTask(sectionIdentifier) {\n        const action = createTaskAction(sectionIdentifier)\n        store.dispatch(action)\n    }\n\n    static deleteTask(id) {\n        const action = deleteTaskAction(id)\n        store.dispatch(action)\n    }\n\n\n    static deleteAllCompleted() {\n        const action = deleteAllCompletedTasksAction()\n        store.dispatch(action)\n    }\n\n    static todo() {\n        return store.getState()\n        .tasks.filter(task => task.isCompleted === false)\n    }\n\n    static completed() {\n        return store.getState()\n        .tasks.filter(task => task.isCompleted === true)\n    }\n\n    // new function to return general tasks, not finished yet\n\n    static getTasks(identifier) {\n        return store.getState().sections.filter(section => section.identifier === identifier)\n    }\n\n    // new function to get sections\n\n    static getSections() {\n        return store.getState().sections\n    }\n\n\n    static createSection() {\n        const action = createSectionAction()\n        store.dispatch(action)\n    }\n\n    static deleteSection(sectionIdentifier) {\n        const action = deleteSectionAction(sectionIdentifier)\n        store.dispatch(action)\n    }\n\n    static updateSectionText(sectionIdentifier,text) {\n        const action = updateSectionTextAction(sectionIdentifier,text)\n        store.dispatch(action)\n    }\n\n    static toggleSection(sectionIdentifier) {\n        const action = toggleSectionAction(sectionIdentifier)\n        store.dispatch(action)\n    }\n\n    static clearAllSectionsAndTasks() {\n        const action = clearAllSectionsAndTasksAction()\n        store.dispatch(action)\n    }\n\n\n};\n\n\nexport default TaskDataController","import ActionMenuItem from \"./ActionMenuItem.js\"\nimport \"../../css/action_list.css\"\nimport TaskDataController from \"../../modules/dataController/TaskDataController.js\"\nimport { faMinus, faPlus } from \"@fortawesome/free-solid-svg-icons\"\nimport AppDataController from \"../../modules/dataController/AppDataController.js\"\n\n\n/*\nprops: {\n    menuItems: MenuItem[]\n}\n\nmenuItem {\n    text: string;\n\n    command: Function\n}\n*/\n\n\nfunction deleteAll() {\n    // deletes all completed Tasks\n    TaskDataController.deleteAllCompleted()\n}\n\nfunction ClearAll() {\n    // Resets the tasks and sections to default and shows the undo prompt for three seconds..\n    TaskDataController.clearAllSectionsAndTasks()\n    AppDataController.showUndo()\n    setTimeout( () => {\n        AppDataController.hideUndo()\n    },3000)\n}\n\n\nconst menuItems = [\n    // Text, commands, and icons present in the action menu.\n    {text: \"Add New Section\", command: TaskDataController.createSection, icon: faPlus},\n    {text: \"Clear Completed Tasks\", command:deleteAll, icon: faMinus},\n    {text: \"Clear All Sections And Tasks\", command: ClearAll, icon: faMinus}\n]\n\nexport default function ActionMenu(props) {\n    // returns a component that contains the commands listed above.\n    return (\n        <button class='overlay'onClick= {AppDataController.closeMenu}\n            aria-label=\"Click here to exit the action menu.\">\n            <div class='action-container'>\n                { menuItems.map(menuItem => {\n                    return <ActionMenuItem {...menuItem} key={menuItem.text}/>\n                })}\n            </div>\n        </button>\n     \n    )\n}","import \"../../css/action_button.css\"\nimport AppDataController from \"../../modules/dataController/AppDataController\"\n\n\n\n\nfunction undoTask() {\n    AppDataController.undoTask()\n    AppDataController.hideUndo()\n}\n\n\n// Creates the component undoButton. On click it'll show the undo button, and hide it after three seconds.\nexport default function UndoButton() {\n    return (\n        <div class=\"undo\"\n            aria-label=\"Press here to undo the last action.\">\n            <p> Items cleared</p>\n            <button alt=\"undo task clear\" onClick={undoTask}> Undo </button>\n        </div >\n    )\n}\n\n\n","import \"../../css/task.css\"\nimport TaskDataController from \"../../modules/dataController/TaskDataController\"\nimport store from \"../../modules/dataController/store\";\n\n/*\nprops: {\n    text:string;\n    isCompleted:boolean\n    id:string \n}\n*/\n\n// This creates the individual task for use on mobile displays. It contains a checkbox, and a input text\n\nexport default function Task(props) {\n    const classes = `task-item`\n    const cssID = props.isCompleted ? 'completedTask' : ''\n\n    // Why hello ugly getAria functions that are 80 lines long! I would love to make these cleaner, but currently\n    // they do what they need to with getting what needs to be returned to the screenReader, and I have one hour\n    // left to turn this in so there it is!\n\n    function getAriaCheckbox(){\n        const currentSectionText = store.getState().sections.find(section => section.identifier === props.sectionID).text\n        if (currentSectionText){\n            if (props.text){\n                if (props.isCompleted){\n                    return \"This is the checked checkbox for the task \" + props.text + \" in\" + currentSectionText\n                }\n                else{\n                    return \"This is the unchecked checkbox for the task \" + props.text + \" in\" + currentSectionText\n                }\n            }\n            else{\n                if (props.isCompleted){\n                    return \"This is the checked checkbox for an empty task in\" + currentSectionText\n                }\n                else{\n                    return \"This is the unchecked checkbox for an empty task in\" + currentSectionText\n                }\n            }\n        }\n        else{\n            if (props.text){\n                if (props.isCompleted){\n                    return \"This is the checked checkbox for the task \" + props.text + \" in an empty section.\"\n                }\n                else{\n                    return \"This is the unchecked checkbox for the task \" + props.text + \" in an empty section.\"\n                }\n            }\n            else{\n                if (props.isCompleted){\n                    return \"This is the checked checkbox for an empty task in in an empty section.\"\n                }\n                else{\n                    return \"This is the unchecked checkbox for an empty task in an empty section.\"\n                }\n            }\n        }\n        }\n\n    function getAriaTask(){\n        const currentSectionText = store.getState().sections.find(section => section.identifier === props.sectionID).text\n        if (currentSectionText){\n            if (props.text){\n                if (props.isCompleted){\n                    return \"edit the completed task \" + props.text + \" in\" + currentSectionText + \".\"\n                }\n                else{\n                    return \"edit the uncompleted task \" + props.text + \" in\" + currentSectionText + \".\"\n                }\n            }\n            else{\n                if (props.isCompleted){\n                    return \"edit the completed empty task in\" + currentSectionText + \".\"\n                }\n                else{\n                    return \"edit the uncompleted empty task  in\" + currentSectionText + \".\"\n                }\n            }\n        }\n        else{\n            if (props.text){\n                if (props.isCompleted){\n                    return \"edit the completed task \" + props.text + \" in an empty section.\"\n                }\n                else{\n                    return \"edit the uncompleted task \" + props.text + \" in an empty section.\"\n                }\n            }\n            else{\n                if (props.isCompleted){\n                    return \"edit a completed empty task in in an empty section.\"\n                }\n                else{\n                    return \"edit a uncompleted empty task in an empty section.\"\n                }\n            }\n        }\n    }\n\n\n    return (\n        <div class={classes}>\n            <input\n                aria-label= {getAriaCheckbox()}\n                alt='task completion status' \n                class='checkbox' \n                type=\"checkbox\"\n                value={ props.isCompleted}\n                onChange= {(e) => handleCheckBoxEvent(props.id, props.sectionID)}\n                checked= {props.isCompleted}\n            />\n            <input\n                aria-label={getAriaTask()}\n                class='task-text' \n                type='text' \n                alt='task text'\n                id ={cssID}\n                onChange= { (e) => handleTextEvent(props.id, props.sectionID,e)}\n                value={props.text}\n            />\n        </div>\n    )\n\n}\n\nfunction handleTextEvent(id, identifier, event) {\n    const text = event.currentTarget.value\n    TaskDataController.updateTaskText(id, identifier, text)\n}\n\nfunction handleCheckBoxEvent(id, identifier) {\n    TaskDataController.toggleTaskCompletion(id, identifier)\n}","import Task from \"./Task\";\n\n\n\n\n\n/*\nprops:{\n    tasks: TaskItem[]\n\n}\n*/\n\n// creates the list of tasks within each section visible in mobile view.\n\nexport default function TaskList(props) {\n    return (\n        <div class='container'>\n            {\n            props.tasks.map(task => {\n            return <Task \n                        {...task}\n                        key={task.id}\n                    />\n            })\n            }\n        </div>   \n    )\n    \n}","import { faAngleDown, faAngleRight } from \"@fortawesome/free-solid-svg-icons\"\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\"\nimport TaskDataController from \"../../modules/dataController/TaskDataController\";\nimport store from \"../../modules/dataController/store\";\n\n\n\n\n// SectionButton refers to the arrow button to show taskslist when in mobile view.\n// This was considered for desktop and landscape view, but difficult would\n// be an understatement in trying to determine scroll length, so that was canned.\n\nfunction SectionButton(props) {\n    const icon = props.toggledState ? faAngleDown : faAngleRight\n\n\n    const sectionText = store.getState().sections.find(section => section.identifier === props.identifier).text\n    // Once again, sectionText is used for the aria-label.\n\n    const ariaText = sectionText ? sectionText : \"an empty \"\n    // This was used for getting further parameters without a if else statement.\n\n\n    return (\n        <button class=\"drop-down\" onClick={(e) => handleOnClick(props.identifier)}\n            aria-label= {props.toggledState ? \"click to close\" + ariaText + \"section\": \"click to open \" + ariaText + \"section\"}\n            >\n            <FontAwesomeIcon icon={icon} />\n        </button>\n    )\n}   \n\n\n\n\nfunction handleOnClick(identifier) {\n    TaskDataController.toggleSection(identifier)\n}\n\n\n\nexport default SectionButton","import \"../../css/bar.css\"\r\nimport \"../../css/todo.css\"\r\nimport \"../../css/completed.css\"\r\n\r\nimport TaskDataController from \"../../modules/dataController/TaskDataController\";\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\"\r\nimport { faPlus } from \"@fortawesome/free-solid-svg-icons\"\r\nimport \"../../css/SectionAddTaskButton.css\"\r\nimport store from \"../../modules/dataController/store\";\r\n\r\n\r\nfunction SectionAddTaskButton(props) {\r\n    // This is a component inside a section's bar that adds a task to the associated section.\r\n\r\n\r\n    // sectionText gets the text of the section, needed because sections are identified by a uuid.\r\n    // this is used to determine whether the sectionText is empty, because the screenreader needs to know\r\n    // if a section title is empty instead of just skipping over it.\r\n    const sectionText = store.getState().sections.find(section => section.identifier === props.identifier).text\r\n\r\n        return (\r\n        <button\r\n            aria-label={sectionText ? \"Press to add a task to \" + sectionText : \"Press to add a task to an empty section\"}\r\n            class=\"add-task-button\"\r\n            onClick={ (e) => handleOnClick(props.identifier)}\r\n        >\r\n            <FontAwesomeIcon icon={faPlus} />\r\n        </button>\r\n    )\r\n}\r\n\r\nfunction handleOnClick(props) {\r\n    TaskDataController.createTask(props)\r\n}\r\n\r\nexport default SectionAddTaskButton","import \"../../css/bar.css\"\nimport SectionButton from \"./SectionButton\"\nimport TaskDataController from \"../../modules/dataController/TaskDataController\";\nimport SectionAddTaskButton from \"./sectionAddTask\";\n\n\n\n// This is the section bar, it contains a button for showing tasklists, an input for editing the section title, and\n// a button to add tasks.\n// A task Add button was considered for the completed tasks section, but this turned out to be a logistical headache\n// as completed tasks when checked uncompleted would return to it's origin, the completed tasks section.\n    // a uncompleted task in a completed task section.\n\nexport default function SectionBar(props) {\n    let cssID;\n\n    // cssID determines if the section is the To do section, completed section, or an added section.\n\n    const classes = `bar ${props.identifier}`\n    if (props.identifier !== 'toDo' && props.identifier !== 'completed'){\n        cssID = \"otherSections\";\n    }\n    else{\n        cssID = props.identifier; // props.identifier contains either \"toDo\", \"completed\", or some uuid string.\n    }\n\n    const checkIfTypeIsCompleted = props.identifier !== \"completed\"\n\n\n    return (\n        <div class={classes} id={\"bar\" + props.identifier}>\n            <SectionButton identifier = {props.identifier}\n                           toggledState = {props.isToggled}/>\n            <input\n                aria-label={props.sectionTitle ? \"Edit the section title of\" + props.sectionTitle : \"Edit the title of an empty section\"}\n                class=\"bar-title\"\n                id={cssID}\n                type='text'\n                alt='task text'\n                onChange= { (e) => handleTextEvent(props.identifier,e)}\n                value={props.sectionTitle}\n            />\n            {/*The code below determines whether the section is completed, and will hide the addTaskButton if it is.*/}\n            {checkIfTypeIsCompleted && <SectionAddTaskButton\n                identifier = {props.identifier}/>}\n        </div>  \n    )\n}\n\nfunction handleTextEvent(id,event) {\n    const text = event.currentTarget.value\n    TaskDataController.updateSectionText(id,text)\n}","import TaskList from \"../Tasks/TaskList.js\"\nimport SectionBar from \"./SectionBar.js\"\n\n\n/*\nprops:\n    This will take in:\n    - identifier: A random uuidv4 for added sections, for To do it's 'toDo', for completed: 'completed'\n    - text: A title, by default it's null, for to do and completed... yeah.\n    - isToggled: false or true, will toggle viewing the tasks\n    - tasks: The list of tasks assigned to each section.\n */\n\n\n\n\nfunction SectionContainer(props) {\n    return (\n        <div>\n            <SectionBar\n                sectionTitle = {props.text}\n                className={props.identifier}\n                identifier ={props.identifier}\n                isToggled = {props.isToggled}\n                />\n            { props.isToggled &&\n                <TaskList tasks={props.tasks}\n                    identifier={props.identifier}/>}\n\n        </div>\n    )\n}\n\n\n\nexport default (SectionContainer)","import SectionContainer from \"./SectionContainer\";\r\nimport TaskDataController from \"../../modules/dataController/TaskDataController\"\r\nimport { connect } from \"react-redux\"\r\nimport React, { useEffect, useState } from 'react';\r\n\r\n/*\r\nprops:{\r\n    sections: Section\r\n\r\n */\r\n\r\nfunction SectionList(props){\r\n    // Creates the container for displaying sections in a mobile display\r\n    return(\r\n        <div class='container'>\r\n            {\r\n                props.sections.map(section => {\r\n                    return <SectionContainer\r\n                        {...section}\r\n                        key={section.identifier}\r\n                    />\r\n                })\r\n            }\r\n        </div>\r\n    )\r\n}\r\n\r\nfunction mapStateToProps(state, ownProps){\r\n    // Used to get the sections for sectionList\r\n    return{\r\n        sections: TaskDataController.getSections()}\r\n}\r\n\r\nexport default connect(mapStateToProps)(SectionList)","import { faAngleDown, faAngleRight } from \"@fortawesome/free-solid-svg-icons\"\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\"\r\nimport \"../../css/Sidebar.css\"\r\n\r\nimport store from \"../../modules/dataController/store\";\r\n\r\n\r\n// The components in otherDisplays are visible when the display is in landscape or in desktop view.\r\n\r\n\r\n\r\nfunction SideBarButton(props) {\r\n    // Sidebar button is treated similarly to SectionButton in newSection,  but does not rotate and will instead\r\n    // scroll to the Section element in sideList\r\n\r\n    const currentSectionText = store.getState().sections.find(section => section.identifier === props.identifier).text\r\n    // another currentSectionText for aria-label!!!\r\n\r\n    const icon = faAngleRight\r\n\r\n    return (\r\n        <button class=\"SideBarButton\" onClick={(e) => handleOnClick(props.identifier)}\r\n        aria-label={currentSectionText ? \"Press to scroll to \" + currentSectionText : \"Press to scroll to a section without a title\"}>\r\n            <FontAwesomeIcon icon={icon} />\r\n        </button>\r\n    )\r\n}\r\n\r\n\r\n\r\n\r\nfunction handleOnClick(identifier) {\r\n    // handles scrolling to the element, uses scrollIntoView to acomplish this.\r\n    // this should work on all popular platforms minus internet explorer, and\r\n    // safari won't support the options like smooth, block, and inline.\r\n\r\n    let sectionToScrollTo = document.getElementById(identifier+\"list\");\r\n    sectionToScrollTo.scrollIntoView({behavior: \"smooth\", block: \"end\", inline: \"nearest\"})\r\n}\r\n\r\n\r\n\r\nexport default SideBarButton","import \"../../css/Sidebar.css\"\r\nimport SideBarButton from \"./sideBarButton\";\r\nimport TaskDataController from \"../../modules/dataController/TaskDataController\";\r\nimport SectionAddTaskButton from \"../newSection/sectionAddTask\";\r\n\r\n\r\n\r\n// Will create the Individual elements inside the sideBarlist.\r\n// contains a sideBarButton, an input field for the section title, and a add task button for the section\r\n\r\nexport default function SideBarElement(props) {\r\n\r\n    // cssID determines whether the sidebar is todo, completed, or a added section.\r\n\r\n    let cssID;\r\n    if (props.identifier !== 'toDo' && props.identifier !== 'completed'){\r\n        cssID = \"otherSectionssideBar\";\r\n    }\r\n    else{\r\n        cssID = props.identifier + \"sideBar\";\r\n    }\r\n\r\n    const checkIfTypeIsCompleted = props.identifier !== \"completed\"\r\n\r\n\r\n\r\n\r\n    return(\r\n        <div\r\n            class=\"sideBarElement\"\r\n            id={cssID}>\r\n            <SideBarButton\r\n                identifier = {props.identifier}/>\r\n            <input\r\n                aria-label={props.text ? \"edit the title for the section \" + props.text : \"edit the title for a section with an empty title\"}\r\n                class=\"bar-title\"\r\n                id={cssID}\r\n                // class=\"bar-title\"\r\n                type='text'\r\n                alt='task text'\r\n                // alt='Section text'\r\n                onChange= { (e) => handleTextEvent(props.identifier,e)}\r\n                value={props.text}/>\r\n            {checkIfTypeIsCompleted && <SectionAddTaskButton\r\n                identifier = {props.identifier}/>}\r\n\r\n        </div>\r\n    )\r\n}\r\n\r\nfunction handleTextEvent(id,event) {\r\n    const text = event.currentTarget.value\r\n    TaskDataController.updateSectionText(id,text)\r\n}","import { connect} from \"react-redux\";\r\nimport TaskDataController from \"../../modules/dataController/TaskDataController\";\r\nimport \"../../css/Sidebar.css\"\r\nimport SideBarElement from \"./sideBarElement\";\r\n\r\n\r\n// Creates the sidebar on the left side of the viewport in desktop/portrait view.\r\n// contains a list of sidebar elements from sideBarElement.\r\n\r\nfunction Sidebar(props){\r\n    return(\r\n            <div class= \"SideBarcontainer\">\r\n                {\r\n                    props.sections.map(section => {\r\n                        return <SideBarElement\r\n                            {...section}\r\n                            key={section.identifier}\r\n                        />\r\n                    })\r\n                }\r\n        </div>\r\n    )\r\n}\r\n\r\nfunction mapStateToProps(state, ownProps){\r\n    return{\r\n        sections: TaskDataController.getSections()}\r\n}\r\n\r\n\r\nexport default connect(mapStateToProps)(Sidebar);","import TaskDataController from \"../../modules/dataController/TaskDataController\"\r\nimport \"../../css/sideList.css\"\r\nimport store from \"../../modules/dataController/store\";\r\n\r\n/*\r\nprops: {\r\n    text:string;\r\n    isCompleted:boolean\r\n    id:string\r\n}\r\n*/\r\n\r\n// this is the sidelistelementtask, which creates the tasks inside the sidelist.\r\n\r\nexport default function SideListElementTask(props) {\r\n    const cssID = props.isCompleted ? 'completedTask' : ''\r\n\r\n\r\n    //I felt that, as messy as this code is, I needed to account for any variables when running a screenReader.\r\n    // For instance, if a task was empty, was there another way to identify it? Shouldn't the section name also\r\n    // be returned when using a screen reader?\r\n    // While very ugly, this means that almost all possible cases have been accounted for.\r\n\r\n    function getAriaCheckbox(){\r\n        // returns what should be said in the screenReader when the checkbox is focused.\r\n\r\n        const currentSectionText = store.getState().sections.find(section => section.identifier === props.sectionID).text\r\n        if (currentSectionText){\r\n            if (props.text){\r\n                if (props.isCompleted){\r\n                    return \"This is the checked checkbox for the task \" + props.text + \" in\" + currentSectionText\r\n                }\r\n                else{\r\n                    return \"This is the unchecked checkbox for the task \" + props.text + \" in\" + currentSectionText\r\n                }\r\n            }\r\n            else{\r\n                if (props.isCompleted){\r\n                    return \"This is the checked checkbox for an empty task in\" + currentSectionText\r\n                }\r\n                else{\r\n                    return \"This is the unchecked checkbox for an empty task in\" + currentSectionText\r\n                }\r\n            }\r\n        }\r\n        else{\r\n            if (props.text){\r\n                if (props.isCompleted){\r\n                    return \"This is the checked checkbox for the task \" + props.text + \" in an empty section.\"\r\n                }\r\n                else{\r\n                    return \"This is the unchecked checkbox for the task \" + props.text + \" in an empty section.\"\r\n                }\r\n            }\r\n            else{\r\n                if (props.isCompleted){\r\n                    return \"This is the checked checkbox for an empty task in in an empty section.\"\r\n                }\r\n                else{\r\n                    return \"This is the unchecked checkbox for an empty task in an empty section.\"\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function getAriaTask(){\r\n        // returns what should be said in the screenReader when the task input text is focused.\r\n\r\n        const currentSectionText = store.getState().sections.find(section => section.identifier === props.sectionID).text\r\n        if (currentSectionText){\r\n            if (props.text){\r\n                if (props.isCompleted){\r\n                    return \"edit the completed task \" + props.text + \" in\" + currentSectionText + \".\"\r\n                }\r\n                else{\r\n                    return \"edit the uncompleted task \" + props.text + \" in\" + currentSectionText + \".\"\r\n                }\r\n            }\r\n            else{\r\n                if (props.isCompleted){\r\n                    return \"edit the completed empty task in\" + currentSectionText + \".\"\r\n                }\r\n                else{\r\n                    return \"edit the uncompleted empty task  in\" + currentSectionText + \".\"\r\n                }\r\n            }\r\n        }\r\n        else{\r\n            if (props.text){\r\n                if (props.isCompleted){\r\n                    return \"edit the completed task \" + props.text + \" in an empty section.\"\r\n                }\r\n                else{\r\n                    return \"edit the uncompleted task \" + props.text + \" in an empty section.\"\r\n                }\r\n            }\r\n            else{\r\n                if (props.isCompleted){\r\n                    return \"edit a completed empty task in in an empty section.\"\r\n                }\r\n                else{\r\n                    return \"edit a uncompleted empty task in an empty section.\"\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return (\r\n        <div class=\"SideListElementTask\">\r\n            <input\r\n                aria-label= {getAriaCheckbox()}\r\n                alt='task completion status'\r\n                class='sideListCheckbox'\r\n                type=\"checkbox\"\r\n                value={ props.isCompleted}\r\n                onChange= {(e) => handleCheckBoxEvent(props.id, props.sectionID)}\r\n                checked= {props.isCompleted}\r\n            />\r\n            <input\r\n                aria-label={getAriaTask()}\r\n                class='SideListElementTaskText'\r\n                type='text'\r\n                alt='task text'\r\n                id ={cssID}\r\n                onChange= { (e) => handleTextEvent(props.id, props.sectionID,e)}\r\n                value={props.text}\r\n            />\r\n        </div>\r\n    )\r\n\r\n}\r\n\r\nfunction handleTextEvent(id, identifier, event) {\r\n    const text = event.currentTarget.value\r\n    TaskDataController.updateTaskText(id, identifier, text)\r\n}\r\n\r\nfunction handleCheckBoxEvent(id, identifier) {\r\n    TaskDataController.toggleTaskCompletion(id, identifier)\r\n}","import TaskDataController from \"../../modules/dataController/TaskDataController\";\r\nimport \"../../css/sideList.css\"\r\nimport SideListElementTask from \"./sideListElementTask\";\r\n\r\n\r\n\r\n// creates the element inside of sidelist, these will contain a section title, a task's checkbox, and a sidelistelement\r\n// task, which is basically a task but in desktop view.\r\n\r\nexport default function SideListElement(props) {\r\n\r\n    return(\r\n        <div\r\n            class=\"SideListElement\"\r\n            aria-label={props.text ? \"this is the section for \" + props.text : \"this is a section without a title.\"}\r\n            id = {props.identifier+\"list\"}>\r\n            <input\r\n                aria-label={props.text ? \"Edit the title for section \" + props.text : \"edit the title for a section without a title.\"}\r\n                className=\"sideListTitle\"\r\n                // class=\"bar-title\"\r\n                type='text'\r\n                alt='task text'\r\n                // alt='Section text'\r\n                onChange={(e) => handleTextEvent(props.identifier, e)}\r\n                value={props.text}\r\n            />\r\n            <div class='sideListTask'>{\r\n                props.tasks.map(task => {\r\n                    return <SideListElementTask\r\n                        {...task}\r\n                        key={task.id}\r\n                    />\r\n                })\r\n            }\r\n\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nfunction handleTextEvent(id,event) {\r\n    const text = event.currentTarget.value\r\n    TaskDataController.updateSectionText(id,text)\r\n}\r\n","import { connect } from \"react-redux\"\r\nimport TaskDataController from \"../../modules/dataController/TaskDataController\"\r\nimport SideListElement from \"./sideListElement\";\r\nimport React, { useEffect, useState } from 'react';\r\n\r\n\r\n\r\n// Creates the scrollable list on the right side of the viewport made up of sideListElements\r\nfunction SideList(props){\r\n\r\n    return(\r\n        <div class='SideListContainer' id=\"theSideListContainer\">\r\n            {\r\n                props.sections.map(section => {\r\n                    return <SideListElement\r\n                        {...section}\r\n                        key={section.identifier}\r\n                    />\r\n                })\r\n            }\r\n        </div>\r\n    )\r\n}\r\n\r\n\r\nfunction mapStateToProps(state, ownProps){\r\n    return{\r\n        sections: TaskDataController.getSections()}\r\n}\r\n\r\nexport default connect(mapStateToProps)(SideList)","import \"../css/banner.css\"\r\n\r\n\r\n\r\n// This is the pink background for the sidebar.\r\nexport default function SideBarBackground(props) {\r\n\r\n    return (\r\n        <div class=\"SideBarBackground\">\r\n        </div>\r\n    )\r\n}","import \"./css/global.css\"\nimport \"typeface-roboto\"\nimport ActionButton from \"./components/Action Commands/ActionButton\";\nimport AppDataController from \"./modules/dataController/AppDataController\";\nimport Header from './components/Header';\n\nimport ActionMenu from \"./components/Action Commands/ActionMenu\";\nimport { connect } from \"react-redux\";\nimport UndoButton from \"./components/Undo/UndoButton\";\nimport SectionList from \"./components/newSection/SectionList\";\n\n\nimport Sidebar from \"./components/otherDisplays/sideBarList\";\nimport SideList from \"./components/otherDisplays/sideList\";\n\nimport SideBarBackground from \"./components/SideBarBackground\";\n\n\n\nfunction App({menuIsActive,showUndo}) {\n    // contains a header, a background for the sidebar,and a div for displaying the\n    // sidebar and sidelist in desktop view next to eachother.\n\n  return (\n    <div class='hello'>\n      <Header/>\n      <SideBarBackground/>\n        <div className=\"wideScreenDisplay\">\n            <div className=\"Sidebar\"><Sidebar/></div>\n            <div className=\"Sidelist\"><SideList/></div>\n\n        </div>\n        <SectionList/>\n      { menuIsActive && <ActionMenu/> }\n        { showUndo && <UndoButton/> }\n      <ActionButton/>\n    </div>\n  );\n}\n\n\nfunction mapToState(state) {\n  return {\n    menuIsActive: AppDataController.menuIsActive(),\n    showUndo: AppDataController.undoIsActive()\n  }\n}\n\nexport default connect(mapToState)(App)","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { Provider } from \"react-redux\"\nimport store from \"./modules/dataController/store.js\"\n\nReactDOM.render(\n  <Provider store={store}>\n    <App/>\n  </Provider>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}